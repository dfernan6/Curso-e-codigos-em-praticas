\PARA ACESSAR MONGODB COM O COMPASS
~$ mongosh "mongodb+srv://Dfernan6:Hatebreede@1987@cluster0.eq41cux.mongodb.net/" --apiVersion 1 --username Dfernan6


In MongoDB, the save method was used in earlier versions to either insert a new document or update an existing document based on its _id field.
However, it has been deprecated and removed from the MongoDB server as of version 3.2. The preferred method for inserting or updating documents is to use insertOne,
insertMany, updateOne, or updateMany methods, depending on your use case.

Here's an example of how you might rewrite your query using insertOne to insert a new document into the "billingCycle" collection:

javascript
Copy code
db.billingCycle.insertOne({
  name: 'Fevereiro/17',
  month: 2,
  year: 2017
});

db.grades.insertMany([
  {
    student_id: 546789,
    products: [
      {
        type: "quiz",
        score: 50,
      },
      {
        type: "homework",
        score: 70,
      },
      {
        type: "quiz",
        score: 66,
      },
      {
        type: "exam",
        score: 70,
      },
    ],
    class_id: 551,
  },
  {
    student_id: 777777,
    products: [
      {
        type: "exam",
        score: 83,
      },
      {
        type: "quiz",
        score: 59,
      },
      {
        type: "quiz",
        score: 72,
      },
      {
        type: "quiz",
        score: 67,
      },
    ],
    class_id: 550,
  },
  {
    student_id: 223344,
    products: [
      {
        type: "exam",
        score: 45,
      },
      {
        type: "homework",
        score: 39,
      },
      {
        type: "quiz",
        score: 40,
      },
      {
        type: "homework",
        score: 88,
      },
    ],
    class_id: 551,
  },
])

This assumes that the "billingCycle" collection already exists in your database. If it doesn't, you can create it using the createCollection method:

javascript
Copy code
db.createCollection('billingCycle');
After creating the collection, you can use the insertOne method as shown above. If you are working with multiple documents, you may consider using insertMany for  efficiency.

Remember to adapt the code according to the MongoDB Node.js driver version you are using. The syntax may vary slightly between versions.


db.billingCycle.find({credits: {$exists: false}}).pretty()
db.billingCycle.find({year:2017}).skip(1).limit(1)
db.billingCycle.find({year:2017})
db.billingCycle.find({credits: {$exists: true}}).pretty()

db_finance> db.billingCycle.update(
... {$and:[{month: 1},{year:2017}]},
... {$set:{credits:[{name:"Salário", value:5000}]}}
... )
DeprecationWarning: Collection.update() is deprecated. Use updateOne, updateMany, or bulkWrite.
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}


db_finance> db.billingCycle.update(
... {$and:[{month: 1},{year:2017}]},
... {$set:{credits:[{name:"Salário", value:5000}]}}
... )
DeprecationWarning: Collection.update() is deprecated. Use updateOne, updateMany, or bulkWrite.
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}

 db.billingCycle.find({credits: {$exists: true}},{_id:0, name:1}).pretty()
[ { name: 'Janeiro/17' }, { name: 'Março' } ]

db.billingCycle.count()
DeprecationWarning: Collection.count() is deprecated. Use countDocuments or estimatedDocumentCount.
3

db.billingCycles.remove({month:2})
DeprecationWarning: Collection.remove() is deprecated. Use deleteOne, deleteMany, findOneAndDelete, or bulkWrite.
{ acknowledged: true, deletedCount: 0 }

db_finance> db.billingCycles.countDocuments()
0
db.billingCycles.estimatedDocumentCount()
0
db.billingCycle.count()
3
db.billingCycle.deleteOne({month:2})
{ acknowledged: true, deletedCount: 1 }
db.billingCycle.count()
2
db.billingCycle.deleteOne({year:2017}, 1)
{ acknowledged: true, deletedCount: 1 }
db_finance> db.dropDatabase()

Finding Documents in a MongoDB Collection
Review the following code, which demonstrates how to query documents in MongoDB.

Find a Document with Equality
When given equality with an _id field, the find() command will return the specified document that matches the _id. Here's an example:

db.zips.find({ _id: ObjectId("5c8eccc1caa187d17ca6ed16") })
Find a Document by Using the $in Operator
Use the $in operator to select documents where the value of a field equals any value in the specified array. Here's an example:

db.zips.find({ city: { $in: ["PHOENIX", "CHICAGO"] } })

Finding Documents by Using Comparison Operators
Review the following comparison operators: $gt, $lt, $lte, and $gte.

$gt
Use the $gt operator to match documents with a field greater than the given value. For example:

db.sales.find({ "items.price": { $gt: 50}})
$lt
Use the $lt operator to match documents with a field less than the given value. For example:

db.sales.find({ "items.price": { $lt: 50}})
$lte
Use the $lte operator to match documents with a field less than or equal to the given value. For example:

db.sales.find({ "customer.age": { $lte: 65}})
$gte
Use the $gte operator to match documents with a field greater than or equal to the given value. For example:

db.sales.find({ "customer.age": { $gte: 65}})

Querying on Array Elements in MongoDB
Review the following code, which demonstrates how to query array elements in MongoDB.

Find Documents with an Array That Contains a Specified Value
In the following example, "InvestmentFund" is not enclosed in square brackets, so MongoDB returns all documents within the products array that contain the specified value.

db.accounts.find({ products: "InvestmentFund"})
Find a Document by Using the $elemMatch Operator
Use the $elemMatch operator to find all documents that contain the specified subdocument. For example:

db.sales.find({
  items: {
    $elemMatch: { name: "laptop", price: { $gt: 800 }, quantity: { $gte: 1 } },
  },
})

db.transactions.find({
    transactions: {
      $elemMatch: { amount: { $lte: 4500 }, transaction_code: "sell" },
    },
  })
  
Finding Documents by Using Logical Operators
Review the following logical operators: implicit $and, $or, and $and.

Find a Document by Using Implicit $and
Use implicit $and to select documents that match multiple expressions. For example:

db.routes.find({ "airline.name": "Southwest Airlines", stops: { $gte: 1 } })
Find a Document by Using the $or Operator
Use the $or operator to select documents that match at least one of the included expressions. For example:

db.routes.find({
  $or: [{ dst_airport: "SEA" }, { src_airport: "SEA" }],
})
Find a Document by Using the $and Operator
Use the $and operator to use multiple $or expressions in your query.

db.routes.find({
  $and: [
    { $or: [{ dst_airport: "SEA" }, { src_airport: "SEA" }] },
    { $or: [{ "airline.name": "American Airlines" }, { airplane: 320 }] },
  ]
})

db.sales.find({
  couponUsed: true,
  purchaseMethod: "Online",
  "customer.age": { $lte: 25 }
})

Replacing a Document in MongoDB
To replace documents in MongoDB, we use the replaceOne() method. The replaceOne() method takes the following parameters:

filter: A query that matches the document to replace.
replacement: The new document to replace the old one with.
options: An object that specifies options for the update.
In the previous video, we use the _id field to filter the document. In our replacement document, we provide the entire document that should be inserted in its place.
Here's the example code from the video:

Use the findOne() command to locate the document to replace.

db.birds.findOne({ common_name: "Northern Cardinal" })
{
  _id: ObjectId("6286809e2f3fa87b7d86dccd"),
  common_name: 'Northern Cardinal',
  scientific_name: 'Cardinalis cardinalis',
  wingspan_cm: 25.32,
  habitat: 'woodlands',
  diet: [ 'grain', 'seeds', 'fruit' ],
  last_seen: ISODate("2022-05-19T20:20:44.083Z")
}

To replace the document, use the replaceOne() method which accepts a query and a replacement document.

db.books.replaceOne(
  {
    _id: ObjectId("6282afeb441a74a98dbbec4e"),
  },
  {
    title: "Data Science Fundamentals for Python and MongoDB",
    isbn: "1484235967",
    publishedDate: new Date("2018-5-10"),
    thumbnailUrl:
      "https://m.media-amazon.com/images/I/71opmUBc2wL._AC_UY218_.jpg",
    authors: ["David Paper"],
    categories: ["Data Science"],
  }
)

Updating MongoDB Documents by Using updateOne()
The updateOne() method accepts a filter document, an update document, and an optional options object. MongoDB provides update operators and options to help you update documents. 
In this section, we'll cover three of them: $set, upsert, and $push.

$set
The $set operator replaces the value of a field with the specified value, as shown in the following code:

db.podcasts.updateOne(
  {
    _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8"),
  },

  {
    $set: {
      subscribers: 98562,
    },
  }
)
upsert
The upsert option creates a new document if no documents match the filtered criteria. Here's an example:

db.podcasts.updateOne(
  { title: "The Developer Hub" },
  { $set: { topics: ["databases", "MongoDB"] } },
  { upsert: true }
)
$push
The $push operator adds a new value to the hosts array field. Here's an example:

db.podcasts.updateOne(
  { _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8") },
  { $push: { hosts: "Nic Raboy" } }
)

db.birds.updateOne(
  { _id: ObjectId("6268471e613e55b82d7065d7") },
  {
    $push: {
      diet: { $each: ["newts", "opossum", "skunks", "squirrels"] },
    },
  }
)

Updating MongoDB Documents by Using findAndModify()
The findAndModify() method is used to find and replace a single document in MongoDB. It accepts a filter document, a replacement document, and an optional options object. 
The following code shows an example:

db.podcasts.findAndModify({
  query: { _id: ObjectId("6261a92dfee1ff300dc80bf1") },
  update: { $inc: { subscribers: 1 } },
  new: true,
})

Updating MongoDB Documents by Using updateMany()
To update multiple documents, use the updateMany() method. This method accepts a filter document, an update document, and an optional options object. The following code shows an example:

db.books.updateMany(
  { publishedDate: { $lt: new Date("2019-01-01") } },
  { $set: { status: "LEGACY" } }
)


Deleting Documents in MongoDB
To delete documents, use the deleteOne() or deleteMany() methods. Both methods accept a filter document and an options object.

Delete One Document
The following code shows an example of the deleteOne() method:

db.podcasts.deleteOne({ _id: Objectid("6282c9862acb966e76bbf20a") })
Delete Many Documents
The following code shows an example of the deleteMany() method:

db.podcasts.deleteMany({category: “crime”})

MongoDB CRUD Operations: Replace and Delete Documents
In this unit, you learned how to modify query results with MongoDB. Specifically, you:

Replaced a single document by using db.collection.replaceOne().
Updated a field value by using the $set update operator in db.collection.updateOne().
Added a value to an array by using the $push update operator in db.collection.updateOne().
Added a new field value to a document by using the upsert option in db.collection.updateOne().
Found and modified a document by using db.collection.findAndModify().
Updated multiple documents by using db.collection.updateMany().
Deleted a document by using db.collection.deleteOne().

Sorting and Limiting Query Results in MongoDB
Review the following code, which demonstrates how to sort and limit query results.

Sorting Results
Use cursor.sort() to return query results in a specified order. Within the parentheses of sort(), include an object that specifies the field(s) to sort by and the order of the sort. Use 1 for ascending order, and -1 for descending order.

Syntax:

db.collection.find(<query>).sort(<sort>)
Example:

// Return data on all music companies, sorted alphabetically from A to Z.
db.companies.find({ category_code: "music" }).sort({ name: 1 });
To ensure documents are returned in a consistent order, include a field that contains unique values in the sort. An easy way to do this is to include the _id field in the sort. Here's an example:

// Return data on all music companies, sorted alphabetically from A to Z. Ensure consistent sort order
db.companies.find({ category_code: "music" }).sort({ name: 1, _id: 1 });
Limiting Results
Use cursor.limit() to return query results in a specified order. Within the parentheses of limit(), specify the maximum number of documents to return.

Syntax:

db.companies.find(<query>).limit(<number>)
Example:

// Return the three music companies with the highest number of employees. Ensure consistent sort order.
db.companies
  .find({ category_code: "music" })
  .sort({ number_of_employees: -1, _id: 1 })
  .limit(3);

Returning Specific Data from a Query in MongoDB
Review the following code, which demonstrates how to return selected fields from a query.

Add a Projection Document
To specify fields to include or exclude in the result set, add a projection document as the second parameter in the call to db.collection.find().

Syntax:

db.collection.find( <query>, <projection> )
Include a Field
To include a field, set its value to 1 in the projection document.

Syntax:

db.collection.find( <query>, { <field> : 1 })
Example:

// Return all restaurant inspections - business name, result, and _id fields only
db.inspections.find(
  { sector: "Restaurant - 818" },
  { business_name: 1, result: 1 }
)
Exclude a Field
To exclude a field, set its value to 0 in the projection document.

Syntax:

db.collection.find(query, { <field> : 0, <field>: 0 })
Example:

// Return all inspections with result of "Pass" or "Warning" - exclude date and zip code
db.inspections.find(
  { result: { $in: ["Pass", "Warning"] } },
  { date: 0, "address.zip": 0 }
)
While the _id field is included by default, it can be suppressed by setting its value to 0 in any projection.

// Return all restaurant inspections - business name and result fields only
db.inspections.find(
  { sector: "Restaurant - 818" },
  { business_name: 1, result: 1, _id: 0 }
)

Counting Documents in a MongoDB Collection
Review the following code, which demonstrates how to count the number of documents that match a query.

Count Documents
Use db.collection.countDocuments() to count the number of documents that match a query. countDocuments() takes two parameters: a query document and an options document.

Syntax:

db.collection.countDocuments( <query>, <options> )
The query selects the documents to be counted.

Examples:

// Count number of docs in trip collection
db.trips.countDocuments({})
// Count number of trips over 120 minutes by subscribers
db.trips.countDocuments({ tripduration: { $gt: 120 }, usertype: "Subscriber" })

db.sales.countDocuments({ items: { $elemMatch: { name: "laptop", price: { $lt: 600 } } } } )
397

MongoDB CRUD Operations: Modifying Query Results
In this unit, you learned how to modify query results with MongoDB. Specifically, you learned how to:

Return query results in a specified order by using cursor.sort().

Constrained the number of results returned by using cursor.limit().

Specified fields to return by adding a projection document parameter in calls to db.collection.find().

Counted the number of documents that match a query by using db.collection.countDocuments().

Inserting a Document in Node.js Applications
Review the following code, which demonstrates how to insert a single document and multiple documents into a collection.


Insert a Document
To insert a single document into a collection, append insertOne() to the collection variable. The insertOne() method accepts a document as an argument and 
returns a promise. In this example, the document that's being inserted is stored in a variable called sampleAccount, which is declared just above the 
main() function.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

const sampleAccount = {
 account_holder: "Linus Torvalds",
 account_id: "MDB829001337",
 account_type: "checking",
 balance: 50352434,
}

const main = async () => {
 try {
   await connectToDatabase()
   // insertOne method is used here to insert the sampleAccount document
   let result = await accountsCollection.insertOne(sampleAccount)
   console.log(`Inserted document: ${result.insertedId}`)
 } catch (err) {
   console.error(`Error inserting document: ${err}`)
 } finally {
   await client.close()
 }
}
 
main()

Insert Many Documents
To insert more than one document, append the insertMany() method to the collection object, and then pass an array of documents to the insertMany() method. The insertMany() method returns a promise. We await the promise to get the result of the operation, which we then use to log the number of documents that are inserted to the console. In this example, the accounts to be inserted are stored in an array variable called sampleAccounts. This variable is defined just above the main() function.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

const sampleAccounts = [
 {
   account_id: "MDB011235813",
   account_holder: "Ada Lovelace",
   account_type: "checking",
   balance: 60218,
 },
 {
   account_id: "MDB829000001",
   account_holder: "Muhammad ibn Musa al-Khwarizmi",
   account_type: "savings",
   balance: 267914296,
 },
]
 
const main = async () => {
 try {
   await connectToDatabase()
   let result = await accountsCollection.insertMany(sampleAccounts)
   console.log(`Inserted ${result.insertedCount} documents`)
   console.log(result)
 } catch (err) {
   console.error(`Error inserting documents: ${err}`)
 } finally {
   await client.close()
 }
}

main()

Querying a MongoDB Collection in Node.js Applications
Review the following code, which demonstrates how to query documents in MongoDB with Node.js.

Using find()
The find() method is a read operation that returns a cursor to the documents that match the query. The find() method takes a query or filter document as an
 argument. If you do not specify a query document, the find() method returns all documents in the collection.

In this example, we find all accounts that have a balance greater than or equal to 4700. The find() method accepts a query filter, which we assign to a 
variable called documentsToFind. We process each document that’s returned from the find() method by iterating the cursor, which is assigned to the variable 
result.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

// Document used as a filter for the find() method
const documentsToFind = { balance: { $gt: 4700 } }
 
const main = async () => {
 try {
   await connectToDatabase()
   // find() method is used here to find documents that match the filter
   let result = accountsCollection.find(documentsToFind)
   let docCount = accountsCollection.countDocuments(documentsToFind)
   await result.forEach((doc) => console.log(doc))
   console.log(`Found ${await docCount} documents`)
 } catch (err) {
   console.error(`Error finding documents: ${err}`)
 } finally {
   await client.close()
 }
}

main()

Using findOne()
In this example, we return a single document from a query, which is assigned to a variable called documentToFind. We use the findOne() method on the 
collection object to return the first document that matches the filter criteria, which are defined in the documentToFind variable.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

// Document used as a filter for the findOne() method
const documentToFind = { _id: ObjectId("62a3638521a9ad028fdf77a3") }

const main = async () => {
 try {
   await connectToDatabase()
   // findOne() method is used here to find a the first document that matches the filter
   let result = await accountsCollection.findOne(documentToFind)
   console.log(`Found one document`)
   console.log(result)
 } catch (err) {
   console.error(`Error finding document: ${err}`)
 } finally {
   await client.close()
 }
}

main()

Updating Documents in Node.js Applications
Review the following code, which demonstrates how to update documents in MongoDB with Node.js.


Using updateOne()
In this example, we use the updateOne() to update the value of an existing field in a document. Append the updateOne() method to the collection object to
update a single document that matches the filter criteria, which are stored in the documentToUpdate variable. The update document contains the changes to
be made and is stored in the update variable.

const dbname = "bank"
const collection_name = "accounts"

const accountsCollection = client.db(dbname).collection(collection_name)

const documentToUpdate = { _id: ObjectId("62d6e04ecab6d8e130497482") }

const update = { $inc: { balance: 100 } }


const main = async () => {
  try {
    await connectToDatabase()
    let result = await accountsCollection.updateOne(documentToUpdate, update)
    result.modifiedCount === 1
      ? console.log("Updated one document")
      : console.log("No documents updated")
  } catch (err) {
    console.error(`Error updating document: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Using updateMany()
In this example, we update many documents by adding a value to the transfers_complete array of all checking account documents. The updateMany() method is
appended to the collection object. The method accepts a filter that matches the document(s) that we want to update and an update statement that
instructs the driver how to change the matching document. Both the filter and the update documents are stored in variables. The updateMany() method updates 
all the documents in the collection that match the filter.

const database = client.db(dbname);
const bank = database.collection(collection_name);

const documentsToUpdate = { account_type: "checking" };

const update = { $push: { transfers_complete: "TR413308000" } }

const main = async () => {
  try {
    await connectToDatabase()
    let result = await accountsCollection.updateMany(documentsToUpdate, update)
    result.modifiedCount > 0
      ? console.log(`Updated ${result.modifiedCount} documents`)
      : console.log("No documents updated")
  } catch (err) {
    console.error(`Error updating documents: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Deleting Documents in Node.js Applications
Review the following code, which demonstrates how to delete documents in MongoDB with Node.js.


Using deleteOne()
To delete a single document from a collection, use the deleteOne() method on a collection object. This method accepts a query filter that matches the 
document that you want to delete. If you do not specify a filter, MongoDB matches and deletes the first document in the collection. Here's an example:

const dbname = "bank"
const collection_name = "accounts"

const accountsCollection = client.db(dbname).collection(collection_name)

const documentToDelete = { _id: ObjectId("62d6e04ecab6d8e13049749c") }

const main = async () => {
  try {
    await connectToDatabase()
    let result = await accountsCollection.deleteOne(documentToDelete)
    result.deletedCount === 1
      ? console.log("Deleted one document")
      : console.log("No documents deleted")
  } catch (err) {
    console.error(`Error deleting documents: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Using deleteMany()
You can delete multiple documents from a collection in a single operation by calling the deleteMany() method on a collection object. To specify which
documents to delete, pass a query filter that matches the documents that you want to delete. If you provide an empty document, MongoDB matches all 
documents in the collection and deletes them. In the following example, we delete all accounts with a balance of less than 500 by using a query filter. 
Then, we print the total number of deleted documents.

const dbname = "bank"
const collection_name = "accounts"

const accountsCollection = client.db(dbname).collection(collection_name)

const documentsToDelete = { balance: { $lt: 500 } }

const main = async () => {
 try {
   await connectToDatabase()
   let result = await accountsCollection.deleteMany(documentsToDelete)
   result.deletedCount > 0
     ? console.log(`Deleted ${result.deletedCount} documents`)
     : console.log("No documents deleted")
 } catch (err) {
   console.error(`Error deleting documents: ${err}`)
 } finally {
   await client.close()
 }
}
 
main()

Creating MongoDB Transactions in Node.js Applications
Review the following code, which demonstrates how to create multi-document transactions in MongoDB with Node.js.


Creating a Transaction
In this section, we'll go through the code to create a transaction step by step. We start the transaction by using the session’s withTransaction() method. 
We then define the sequence of operations to perform inside the transactions, passing the session object to each operation in the transactions.



Create variables used in the transaction.
// Collections
const accounts = client.db("bank").collection("accounts")
const transfers = client.db("bank").collection("transfers")

// Account information
let account_id_sender = "MDB574189300"
let account_id_receiver = "MDB343652528"
let transaction_amount = 100

Start a new session.
const session = client.startSession()

Begin a transaction with the WithTransaction() method on the session.
const transactionResults = await session.withTransaction(async () => {
  // Operations will go here
})

Update the balance field of the sender’s account by decrementing the transaction_amount from the balance field.
const senderUpdate = await accounts.updateOne(
  { account_id: account_id_sender },
  { $inc: { balance: -transaction_amount } },
  { session }
)

Update the balance field of the receiver’s account by incrementing the transaction_amount to the balance field.
const receiverUpdate = await accounts.updateOne(
  { account_id: account_id_receiver },
  { $inc: { balance: transaction_amount } },
  { session }
)

Create a transfer document and insert it into the transfers collection.
const transfer = {
  transfer_id: "TR21872187",
  amount: 100,
  from_account: account_id_sender,
  to_account: account_id_receiver,
}

const insertTransferResults = await transfers.insertOne(transfer, { session })

Update the transfers_complete array of the sender’s account by adding the transfer_id to the array.
const updateSenderTransferResults = await accounts.updateOne(
  { account_id: account_id_sender },
  { $push: { transfers_complete: transfer.transfer_id } },
  { session }
)

Update the transfers_complete array of the receiver’s account by adding the transfer_id to the array.
const updateReceiverTransferResults = await accounts.updateOne(
  { account_id: account_id_receiver },
  { $push: { transfers_complete: transfer.transfer_id } },
  { session }
)

Log a message regarding the success or failure of the transaction.
if (transactionResults) {
  console.log("Transaction completed successfully.")
} else {
  console.log("Transaction failed.")
}

Catch any errors and close the session.
} catch (err) {
  console.error(`Transaction aborted: ${err}`)
  process.exit(1)
} finally {
  await session.endSession()
  await client.close()
}

Introduction to MongoDB Aggregation
This section contains key definitions for this lesson, as well as the code for an aggregation pipeline.

Definitions
Aggregation: Collection and summary of data

Stage: One of the built-in methods that can be completed on the data, but does not permanently alter it

Aggregation pipeline: A series of stages completed on the data in order

Structure of an Aggregation Pipeline
db.collection.aggregate([
    {
        $stage1: {
            { expression1 },
            { expression2 }...
        },
        $stage2: {
            { expression1 }...
        }
    }
])

Using $match and $group Stages in a MongoDB Aggregation Pipeline
Review the following sections, which show the code for the $match and $group aggregation stages.

$match
The $match stage filters for documents that match specified conditions. Here's the code for $match:

{
  $match: {
     "field_name": "value"
  }
}
$group
The $group stage groups documents by a group key.

{
  $group:
    {
      _id: <expression>, // Group key
      <field>: { <accumulator> : <expression> }
    }
 }
$match and $group in an Aggregation Pipeline
The following aggregation pipeline finds the documents with a field named "state" that matches a value "CA" and then groups those documents by the group 
key "$city" and shows the total number of zip codes in the state of California.

db.zips.aggregate([
{   
   $match: { 
      state: "CA"
    }
},
{
   $group: {
      _id: "$city",
      totalZips: { $count : { } }
   }
}
])

Using $sort and $limit Stages in a MongoDB Aggregation Pipeline
Review the following sections, which show the code for the $sort and $limit aggregation stages.

$sort
The $sort stage sorts all input documents and returns them to the pipeline in sorted order. We use 1 to represent ascending order, and -1 to represent 
descending order.

{
    $sort: {
        "field_name": 1
    }
}


$limit
The $limit stage returns only a specified number of records.

{
  $limit: 5
}


$sort and $limit in an Aggregation Pipeline
The following aggregation pipeline sorts the documents in descending order, so the documents with the greatest pop value appear first, and limits the 
output to only the first five documents after sorting.

db.zips.aggregate([
{
  $sort: {
    pop: -1
  }
},
{
  $limit:  5
}
])
