In MongoDB, the save method was used in earlier versions to either insert a new document or update an existing document based on its _id field.
However, it has been deprecated and removed from the MongoDB server as of version 3.2. The preferred method for inserting or updating documents is to use insertOne,
insertMany, updateOne, or updateMany methods, depending on your use case.

Here's an example of how you might rewrite your query using insertOne to insert a new document into the "billingCycle" collection:

javascript
Copy code
db.billingCycle.insertOne({
  name: 'Fevereiro/17',
  month: 2,
  year: 2017
});

db.grades.insertMany([
  {
    student_id: 546789,
    products: [
      {
        type: "quiz",
        score: 50,
      },
      {
        type: "homework",
        score: 70,
      },
      {
        type: "quiz",
        score: 66,
      },
      {
        type: "exam",
        score: 70,
      },
    ],
    class_id: 551,
  },
  {
    student_id: 777777,
    products: [
      {
        type: "exam",
        score: 83,
      },
      {
        type: "quiz",
        score: 59,
      },
      {
        type: "quiz",
        score: 72,
      },
      {
        type: "quiz",
        score: 67,
      },
    ],
    class_id: 550,
  },
  {
    student_id: 223344,
    products: [
      {
        type: "exam",
        score: 45,
      },
      {
        type: "homework",
        score: 39,
      },
      {
        type: "quiz",
        score: 40,
      },
      {
        type: "homework",
        score: 88,
      },
    ],
    class_id: 551,
  },
])

This assumes that the "billingCycle" collection already exists in your database. If it doesn't, you can create it using the createCollection method:

javascript
Copy code
db.createCollection('billingCycle');
After creating the collection, you can use the insertOne method as shown above. If you are working with multiple documents, you may consider using insertMany for  efficiency.

Remember to adapt the code according to the MongoDB Node.js driver version you are using. The syntax may vary slightly between versions.


db.billingCycle.find({credits: {$exists: false}}).pretty()
db.billingCycle.find({year:2017}).skip(1).limit(1)
db.billingCycle.find({year:2017})
db.billingCycle.find({credits: {$exists: true}}).pretty()

db_finance> db.billingCycle.update(
... {$and:[{month: 1},{year:2017}]},
... {$set:{credits:[{name:"Sal√°rio", value:5000}]}}
... )
DeprecationWarning: Collection.update() is deprecated. Use updateOne, updateMany, or bulkWrite.
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}


db_finance> db.billingCycle.update(
... {$and:[{month: 1},{year:2017}]},
... {$set:{credits:[{name:"Sal√°rio", value:5000}]}}
... )
DeprecationWarning: Collection.update() is deprecated. Use updateOne, updateMany, or bulkWrite.
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}

 db.billingCycle.find({credits: {$exists: true}},{_id:0, name:1}).pretty()
[ { name: 'Janeiro/17' }, { name: 'Mar√ßo' } ]

db.billingCycle.count()
DeprecationWarning: Collection.count() is deprecated. Use countDocuments or estimatedDocumentCount.
3

db.billingCycles.remove({month:2})
DeprecationWarning: Collection.remove() is deprecated. Use deleteOne, deleteMany, findOneAndDelete, or bulkWrite.
{ acknowledged: true, deletedCount: 0 }

db_finance> db.billingCycles.countDocuments()
0
db.billingCycles.estimatedDocumentCount()
0
db.billingCycle.count()
3
db.billingCycle.deleteOne({month:2})
{ acknowledged: true, deletedCount: 1 }
db.billingCycle.count()
2
db.billingCycle.deleteOne({year:2017}, 1)
{ acknowledged: true, deletedCount: 1 }
db_finance> db.dropDatabase()

Finding Documents in a MongoDB Collection
Review the following code, which demonstrates how to query documents in MongoDB.

Find a Document with Equality
When given equality with an _id field, the find() command will return the specified document that matches the _id. Here's an example:

db.zips.find({ _id: ObjectId("5c8eccc1caa187d17ca6ed16") })
Find a Document by Using the $in Operator
Use the $in operator to select documents where the value of a field equals any value in the specified array. Here's an example:

db.zips.find({ city: { $in: ["PHOENIX", "CHICAGO"] } })

Finding Documents by Using Comparison Operators
Review the following comparison operators: $gt, $lt, $lte, and $gte.

$gt
Use the $gt operator to match documents with a field greater than the given value. For example:

db.sales.find({ "items.price": { $gt: 50}})
$lt
Use the $lt operator to match documents with a field less than the given value. For example:

db.sales.find({ "items.price": { $lt: 50}})
$lte
Use the $lte operator to match documents with a field less than or equal to the given value. For example:

db.sales.find({ "customer.age": { $lte: 65}})
$gte
Use the $gte operator to match documents with a field greater than or equal to the given value. For example:

db.sales.find({ "customer.age": { $gte: 65}})

Querying on Array Elements in MongoDB
Review the following code, which demonstrates how to query array elements in MongoDB.

Find Documents with an Array That Contains a Specified Value
In the following example, "InvestmentFund" is not enclosed in square brackets, so MongoDB returns all documents within the products array that contain the specified value.

db.accounts.find({ products: "InvestmentFund"})
Find a Document by Using the $elemMatch Operator
Use the $elemMatch operator to find all documents that contain the specified subdocument. For example:

db.sales.find({
  items: {
    $elemMatch: { name: "laptop", price: { $gt: 800 }, quantity: { $gte: 1 } },
  },
})

db.transactions.find({
    transactions: {
      $elemMatch: { amount: { $lte: 4500 }, transaction_code: "sell" },
    },
  })
  
Finding Documents by Using Logical Operators
Review the following logical operators: implicit $and, $or, and $and.

Find a Document by Using Implicit $and
Use implicit $and to select documents that match multiple expressions. For example:

db.routes.find({ "airline.name": "Southwest Airlines", stops: { $gte: 1 } })
Find a Document by Using the $or Operator
Use the $or operator to select documents that match at least one of the included expressions. For example:

db.routes.find({
  $or: [{ dst_airport: "SEA" }, { src_airport: "SEA" }],
})
Find a Document by Using the $and Operator
Use the $and operator to use multiple $or expressions in your query.

db.routes.find({
  $and: [
    { $or: [{ dst_airport: "SEA" }, { src_airport: "SEA" }] },
    { $or: [{ "airline.name": "American Airlines" }, { airplane: 320 }] },
  ]
})

db.sales.find({
  couponUsed: true,
  purchaseMethod: "Online",
  "customer.age": { $lte: 25 }
})

Replacing a Document in MongoDB
To replace documents in MongoDB, we use the replaceOne() method. The replaceOne() method takes the following parameters:

filter: A query that matches the document to replace.
replacement: The new document to replace the old one with.
options: An object that specifies options for the update.
In the previous video, we use the _id field to filter the document. In our replacement document, we provide the entire document that should be inserted in its place.
Here's the example code from the video:

Use the findOne() command to locate the document to replace.

db.birds.findOne({ common_name: "Northern Cardinal" })
{
  _id: ObjectId("6286809e2f3fa87b7d86dccd"),
  common_name: 'Northern Cardinal',
  scientific_name: 'Cardinalis cardinalis',
  wingspan_cm: 25.32,
  habitat: 'woodlands',
  diet: [ 'grain', 'seeds', 'fruit' ],
  last_seen: ISODate("2022-05-19T20:20:44.083Z")
}

To replace the document, use the replaceOne() method which accepts a query and a replacement document.

db.books.replaceOne(
  {
    _id: ObjectId("6282afeb441a74a98dbbec4e"),
  },
  {
    title: "Data Science Fundamentals for Python and MongoDB",
    isbn: "1484235967",
    publishedDate: new Date("2018-5-10"),
    thumbnailUrl:
      "https://m.media-amazon.com/images/I/71opmUBc2wL._AC_UY218_.jpg",
    authors: ["David Paper"],
    categories: ["Data Science"],
  }
)

Updating MongoDB Documents by Using updateOne()
The updateOne() method accepts a filter document, an update document, and an optional options object. MongoDB provides update operators and options to help you update documents. 
In this section, we'll cover three of them: $set, upsert, and $push.

$set
The $set operator replaces the value of a field with the specified value, as shown in the following code:

db.podcasts.updateOne(
  {
    _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8"),
  },

  {
    $set: {
      subscribers: 98562,
    },
  }
)
upsert
The upsert option creates a new document if no documents match the filtered criteria. Here's an example:

db.podcasts.updateOne(
  { title: "The Developer Hub" },
  { $set: { topics: ["databases", "MongoDB"] } },
  { upsert: true }
)
$push
The $push operator adds a new value to the hosts array field. Here's an example:

db.podcasts.updateOne(
  { _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8") },
  { $push: { hosts: "Nic Raboy" } }
)

db.birds.updateOne(
  { _id: ObjectId("6268471e613e55b82d7065d7") },
  {
    $push: {
      diet: { $each: ["newts", "opossum", "skunks", "squirrels"] },
    },
  }
)

Updating MongoDB Documents by Using findAndModify()
The findAndModify() method is used to find and replace a single document in MongoDB. It accepts a filter document, a replacement document, and an optional options object. 
The following code shows an example:

db.podcasts.findAndModify({
  query: { _id: ObjectId("6261a92dfee1ff300dc80bf1") },
  update: { $inc: { subscribers: 1 } },
  new: true,
})

Updating MongoDB Documents by Using updateMany()
To update multiple documents, use the updateMany() method. This method accepts a filter document, an update document, and an optional options object. The following code shows an example:

db.books.updateMany(
  { publishedDate: { $lt: new Date("2019-01-01") } },
  { $set: { status: "LEGACY" } }
)


Deleting Documents in MongoDB
To delete documents, use the deleteOne() or deleteMany() methods. Both methods accept a filter document and an options object.

Delete One Document
The following code shows an example of the deleteOne() method:

db.podcasts.deleteOne({ _id: Objectid("6282c9862acb966e76bbf20a") })
Delete Many Documents
The following code shows an example of the deleteMany() method:

db.podcasts.deleteMany({category: ‚Äúcrime‚Äù})

MongoDB CRUD Operations: Replace and Delete Documents
In this unit, you learned how to modify query results with MongoDB. Specifically, you:

Replaced a single document by using db.collection.replaceOne().
Updated a field value by using the $set update operator in db.collection.updateOne().
Added a value to an array by using the $push update operator in db.collection.updateOne().
Added a new field value to a document by using the upsert option in db.collection.updateOne().
Found and modified a document by using db.collection.findAndModify().
Updated multiple documents by using db.collection.updateMany().
Deleted a document by using db.collection.deleteOne().

Sorting and Limiting Query Results in MongoDB
Review the following code, which demonstrates how to sort and limit query results.

Sorting Results
Use cursor.sort() to return query results in a specified order. Within the parentheses of sort(), include an object that specifies the field(s) to sort by and the order of the sort. Use 1 for ascending order, and -1 for descending order.

Syntax:

db.collection.find(<query>).sort(<sort>)
Example:

// Return data on all music companies, sorted alphabetically from A to Z.
db.companies.find({ category_code: "music" }).sort({ name: 1 });
To ensure documents are returned in a consistent order, include a field that contains unique values in the sort. An easy way to do this is to include the _id field in the sort. Here's an example:

// Return data on all music companies, sorted alphabetically from A to Z. Ensure consistent sort order
db.companies.find({ category_code: "music" }).sort({ name: 1, _id: 1 });
Limiting Results
Use cursor.limit() to return query results in a specified order. Within the parentheses of limit(), specify the maximum number of documents to return.

Syntax:

db.companies.find(<query>).limit(<number>)
Example:

// Return the three music companies with the highest number of employees. Ensure consistent sort order.
db.companies
  .find({ category_code: "music" })
  .sort({ number_of_employees: -1, _id: 1 })
  .limit(3);

Returning Specific Data from a Query in MongoDB
Review the following code, which demonstrates how to return selected fields from a query.

Add a Projection Document
To specify fields to include or exclude in the result set, add a projection document as the second parameter in the call to db.collection.find().

Syntax:

db.collection.find( <query>, <projection> )
Include a Field
To include a field, set its value to 1 in the projection document.

Syntax:

db.collection.find( <query>, { <field> : 1 })
Example:

// Return all restaurant inspections - business name, result, and _id fields only
db.inspections.find(
  { sector: "Restaurant - 818" },
  { business_name: 1, result: 1 }
)
Exclude a Field
To exclude a field, set its value to 0 in the projection document.

Syntax:

db.collection.find(query, { <field> : 0, <field>: 0 })
Example:

// Return all inspections with result of "Pass" or "Warning" - exclude date and zip code
db.inspections.find(
  { result: { $in: ["Pass", "Warning"] } },
  { date: 0, "address.zip": 0 }
)
While the _id field is included by default, it can be suppressed by setting its value to 0 in any projection.

// Return all restaurant inspections - business name and result fields only
db.inspections.find(
  { sector: "Restaurant - 818" },
  { business_name: 1, result: 1, _id: 0 }
)

Counting Documents in a MongoDB Collection
Review the following code, which demonstrates how to count the number of documents that match a query.

Count Documents
Use db.collection.countDocuments() to count the number of documents that match a query. countDocuments() takes two parameters: a query document and an options document.

Syntax:

db.collection.countDocuments( <query>, <options> )
The query selects the documents to be counted.

Examples:

// Count number of docs in trip collection
db.trips.countDocuments({})
// Count number of trips over 120 minutes by subscribers
db.trips.countDocuments({ tripduration: { $gt: 120 }, usertype: "Subscriber" })

db.sales.countDocuments({ items: { $elemMatch: { name: "laptop", price: { $lt: 600 } } } } )
397

MongoDB CRUD Operations: Modifying Query Results
In this unit, you learned how to modify query results with MongoDB. Specifically, you learned how to:

Return query results in a specified order by using cursor.sort().

Constrained the number of results returned by using cursor.limit().

Specified fields to return by adding a projection document parameter in calls to db.collection.find().

Counted the number of documents that match a query by using db.collection.countDocuments().

Inserting a Document in Node.js Applications
Review the following code, which demonstrates how to insert a single document and multiple documents into a collection.


Insert a Document
To insert a single document into a collection, append insertOne() to the collection variable. The insertOne() method accepts a document as an argument and 
returns a promise. In this example, the document that's being inserted is stored in a variable called sampleAccount, which is declared just above the 
main() function.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

const sampleAccount = {
 account_holder: "Linus Torvalds",
 account_id: "MDB829001337",
 account_type: "checking",
 balance: 50352434,
}

const main = async () => {
 try {
   await connectToDatabase()
   // insertOne method is used here to insert the sampleAccount document
   let result = await accountsCollection.insertOne(sampleAccount)
   console.log(`Inserted document: ${result.insertedId}`)
 } catch (err) {
   console.error(`Error inserting document: ${err}`)
 } finally {
   await client.close()
 }
}
 
main()

Insert Many Documents
To insert more than one document, append the insertMany() method to the collection object, and then pass an array of documents to the insertMany() method. The insertMany() method returns a promise. We await the promise to get the result of the operation, which we then use to log the number of documents that are inserted to the console. In this example, the accounts to be inserted are stored in an array variable called sampleAccounts. This variable is defined just above the main() function.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

const sampleAccounts = [
 {
   account_id: "MDB011235813",
   account_holder: "Ada Lovelace",
   account_type: "checking",
   balance: 60218,
 },
 {
   account_id: "MDB829000001",
   account_holder: "Muhammad ibn Musa al-Khwarizmi",
   account_type: "savings",
   balance: 267914296,
 },
]
 
const main = async () => {
 try {
   await connectToDatabase()
   let result = await accountsCollection.insertMany(sampleAccounts)
   console.log(`Inserted ${result.insertedCount} documents`)
   console.log(result)
 } catch (err) {
   console.error(`Error inserting documents: ${err}`)
 } finally {
   await client.close()
 }
}

main()

Querying a MongoDB Collection in Node.js Applications
Review the following code, which demonstrates how to query documents in MongoDB with Node.js.

Using find()
The find() method is a read operation that returns a cursor to the documents that match the query. The find() method takes a query or filter document as an
 argument. If you do not specify a query document, the find() method returns all documents in the collection.

In this example, we find all accounts that have a balance greater than or equal to 4700. The find() method accepts a query filter, which we assign to a 
variable called documentsToFind. We process each document that‚Äôs returned from the find() method by iterating the cursor, which is assigned to the variable 
result.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

// Document used as a filter for the find() method
const documentsToFind = { balance: { $gt: 4700 } }
 
const main = async () => {
 try {
   await connectToDatabase()
   // find() method is used here to find documents that match the filter
   let result = accountsCollection.find(documentsToFind)
   let docCount = accountsCollection.countDocuments(documentsToFind)
   await result.forEach((doc) => console.log(doc))
   console.log(`Found ${await docCount} documents`)
 } catch (err) {
   console.error(`Error finding documents: ${err}`)
 } finally {
   await client.close()
 }
}

main()

Using findOne()
In this example, we return a single document from a query, which is assigned to a variable called documentToFind. We use the findOne() method on the 
collection object to return the first document that matches the filter criteria, which are defined in the documentToFind variable.

const dbname = "bank"
const collection_name = "accounts"
 
const accountsCollection = client.db(dbname).collection(collection_name)

// Document used as a filter for the findOne() method
const documentToFind = { _id: ObjectId("62a3638521a9ad028fdf77a3") }

const main = async () => {
 try {
   await connectToDatabase()
   // findOne() method is used here to find a the first document that matches the filter
   let result = await accountsCollection.findOne(documentToFind)
   console.log(`Found one document`)
   console.log(result)
 } catch (err) {
   console.error(`Error finding document: ${err}`)
 } finally {
   await client.close()
 }
}

main()

Updating Documents in Node.js Applications
Review the following code, which demonstrates how to update documents in MongoDB with Node.js.


Using updateOne()
In this example, we use the updateOne() to update the value of an existing field in a document. Append the updateOne() method to the collection object to
update a single document that matches the filter criteria, which are stored in the documentToUpdate variable. The update document contains the changes to
be made and is stored in the update variable.

const dbname = "bank"
const collection_name = "accounts"

const accountsCollection = client.db(dbname).collection(collection_name)

const documentToUpdate = { _id: ObjectId("62d6e04ecab6d8e130497482") }

const update = { $inc: { balance: 100 } }


const main = async () => {
  try {
    await connectToDatabase()
    let result = await accountsCollection.updateOne(documentToUpdate, update)
    result.modifiedCount === 1
      ? console.log("Updated one document")
      : console.log("No documents updated")
  } catch (err) {
    console.error(`Error updating document: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Using updateMany()
In this example, we update many documents by adding a value to the transfers_complete array of all checking account documents. The updateMany() method is
appended to the collection object. The method accepts a filter that matches the document(s) that we want to update and an update statement that
instructs the driver how to change the matching document. Both the filter and the update documents are stored in variables. The updateMany() method updates 
all the documents in the collection that match the filter.

const database = client.db(dbname);
const bank = database.collection(collection_name);

const documentsToUpdate = { account_type: "checking" };

const update = { $push: { transfers_complete: "TR413308000" } }

const main = async () => {
  try {
    await connectToDatabase()
    let result = await accountsCollection.updateMany(documentsToUpdate, update)
    result.modifiedCount > 0
      ? console.log(`Updated ${result.modifiedCount} documents`)
      : console.log("No documents updated")
  } catch (err) {
    console.error(`Error updating documents: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Deleting Documents in Node.js Applications
Review the following code, which demonstrates how to delete documents in MongoDB with Node.js.


Using deleteOne()
To delete a single document from a collection, use the deleteOne() method on a collection object. This method accepts a query filter that matches the 
document that you want to delete. If you do not specify a filter, MongoDB matches and deletes the first document in the collection. Here's an example:

const dbname = "bank"
const collection_name = "accounts"

const accountsCollection = client.db(dbname).collection(collection_name)

const documentToDelete = { _id: ObjectId("62d6e04ecab6d8e13049749c") }

const main = async () => {
  try {
    await connectToDatabase()
    let result = await accountsCollection.deleteOne(documentToDelete)
    result.deletedCount === 1
      ? console.log("Deleted one document")
      : console.log("No documents deleted")
  } catch (err) {
    console.error(`Error deleting documents: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Using deleteMany()
You can delete multiple documents from a collection in a single operation by calling the deleteMany() method on a collection object. To specify which
documents to delete, pass a query filter that matches the documents that you want to delete. If you provide an empty document, MongoDB matches all 
documents in the collection and deletes them. In the following example, we delete all accounts with a balance of less than 500 by using a query filter. 
Then, we print the total number of deleted documents.

const dbname = "bank"
const collection_name = "accounts"

const accountsCollection = client.db(dbname).collection(collection_name)

const documentsToDelete = { balance: { $lt: 500 } }

const main = async () => {
 try {
   await connectToDatabase()
   let result = await accountsCollection.deleteMany(documentsToDelete)
   result.deletedCount > 0
     ? console.log(`Deleted ${result.deletedCount} documents`)
     : console.log("No documents deleted")
 } catch (err) {
   console.error(`Error deleting documents: ${err}`)
 } finally {
   await client.close()
 }
}
 
main()

Creating MongoDB Transactions in Node.js Applications
Review the following code, which demonstrates how to create multi-document transactions in MongoDB with Node.js.


Creating a Transaction
In this section, we'll go through the code to create a transaction step by step. We start the transaction by using the session‚Äôs withTransaction() method. 
We then define the sequence of operations to perform inside the transactions, passing the session object to each operation in the transactions.



Create variables used in the transaction.
// Collections
const accounts = client.db("bank").collection("accounts")
const transfers = client.db("bank").collection("transfers")

// Account information
let account_id_sender = "MDB574189300"
let account_id_receiver = "MDB343652528"
let transaction_amount = 100

Start a new session.
const session = client.startSession()

Begin a transaction with the WithTransaction() method on the session.
const transactionResults = await session.withTransaction(async () => {
  // Operations will go here
})

Update the balance field of the sender‚Äôs account by decrementing the transaction_amount from the balance field.
const senderUpdate = await accounts.updateOne(
  { account_id: account_id_sender },
  { $inc: { balance: -transaction_amount } },
  { session }
)

Update the balance field of the receiver‚Äôs account by incrementing the transaction_amount to the balance field.
const receiverUpdate = await accounts.updateOne(
  { account_id: account_id_receiver },
  { $inc: { balance: transaction_amount } },
  { session }
)

Create a transfer document and insert it into the transfers collection.
const transfer = {
  transfer_id: "TR21872187",
  amount: 100,
  from_account: account_id_sender,
  to_account: account_id_receiver,
}

const insertTransferResults = await transfers.insertOne(transfer, { session })

Update the transfers_complete array of the sender‚Äôs account by adding the transfer_id to the array.
const updateSenderTransferResults = await accounts.updateOne(
  { account_id: account_id_sender },
  { $push: { transfers_complete: transfer.transfer_id } },
  { session }
)

Update the transfers_complete array of the receiver‚Äôs account by adding the transfer_id to the array.
const updateReceiverTransferResults = await accounts.updateOne(
  { account_id: account_id_receiver },
  { $push: { transfers_complete: transfer.transfer_id } },
  { session }
)

Log a message regarding the success or failure of the transaction.
if (transactionResults) {
  console.log("Transaction completed successfully.")
} else {
  console.log("Transaction failed.")
}

Catch any errors and close the session.
} catch (err) {
  console.error(`Transaction aborted: ${err}`)
  process.exit(1)
} finally {
  await session.endSession()
  await client.close()
}

Introduction to MongoDB Aggregation
This section contains key definitions for this lesson, as well as the code for an aggregation pipeline.

Definitions
Aggregation: Collection and summary of data

Stage: One of the built-in methods that can be completed on the data, but does not permanently alter it

Aggregation pipeline: A series of stages completed on the data in order

Structure of an Aggregation Pipeline
db.collection.aggregate([
    {
        $stage1: {
            { expression1 },
            { expression2 }...
        },
        $stage2: {
            { expression1 }...
        }
    }
])

Using $match and $group Stages in a MongoDB Aggregation Pipeline
Review the following sections, which show the code for the $match and $group aggregation stages.

$match
The $match stage filters for documents that match specified conditions. Here's the code for $match:

{
  $match: {
     "field_name": "value"
  }
}

$group
The $group stage groups documents by a group key.

{
  $group:
    {
      _id: <expression>, // Group key
      <field>: { <accumulator> : <expression> }
    }
 }

$match and $group in an Aggregation Pipeline
The following aggregation pipeline finds the documents with a field named "state" that matches a value "CA" and then groups those documents by the group 
key "$city" and shows the total number of zip codes in the state of California.

db.zips.aggregate([
{   
   $match: { 
      state: "CA"
    }
},
{
   $group: {
      _id: "$city",
      totalZips: { $count : { } }
   }
}
])

Using $sort and $limit Stages in a MongoDB Aggregation Pipeline
Review the following sections, which show the code for the $sort and $limit aggregation stages.

$sort
The $sort stage sorts all input documents and returns them to the pipeline in sorted order. We use 1 to represent ascending order, and -1 to represent 
descending order.

{
    $sort: {
        "field_name": 1
    }
}


$limit
The $limit stage returns only a specified number of records.

{
  $limit: 5
}


$sort and $limit in an Aggregation Pipeline
The following aggregation pipeline sorts the documents in descending order, so the documents with the greatest pop value appear first, and limits the 
output to only the first five documents after sorting.

db.zips.aggregate([
{
  $sort: {
    pop: -1
  }
},
{
  $limit:  5
}
])

Using $project, $count, and $set Stages in a MongoDB Aggregation Pipeline
Review the following sections, which show the code for the $project, $set, and $count aggregation stages.

$project
The $project stage specifies the fields of the output documents. 1 means that the field should be included, and 0 means that the field should be supressed.
The field can also be assigned a new value.

{
    $project: {
        state:1, 
        zip:1,
        population:"$pop",
        _id:0
    }
}

$set
The $set stage creates new fields or changes the value of existing fields, and then outputs the documents with the new fields.

{
    $set: {
        place: {
            $concat:["$city",",","$state"]
        },
        pop:10000
     }
  }

$count
The $count stage creates a new document, with the number of documents at that stage in the aggregation pipeline assigned to the specified field name.

{
  $count: "total_zips"
}


$out
The $out stage outputs the documents to the authors collection in the reporting database.
db.sightings.aggregate([
  {
    $match: {
      date: {
        $gte: ISODate('2022-01-01T00:00:00.0Z'),
        $lt: ISODate('2023-01-01T00:00:00.0Z')
      }
    }
  },
  {
    $out: 'sightings_2022'
  }
])
db.sightings_2022.findOne()


Using MongoDB Aggregation Stages with Node.js: $match and $group
Review the following code, which demonstrates how to build the $match and $group stages of an aggregation pipeline in MongoDB with Node.js.


Using $match
Aggregation gives you a way to transform data from your collection by passing documents from one stage to another. These stages can consist of operators 
that transform or organize your data in a specific way. In this lesson, we used $match and $group.

The $match stage filters documents by using a simple equality match, like $match: { author: "Dave"}, or aggregation expressions using comparison 
operators, like $match: { likes: { $gt: 100 } }. This operator accepts a query document and passes the resulting documents to the next stage. $match should
 be placed early in your pipeline to reduce the number of documents to process.


Using $group
The $group stage separates documents according to a group key and returns one document for every unique group key. The group key is usually a field in the
document, but it can also be an expression that resolves to a field. The $group stage can be used with aggregation expressions to perform calculations on 
the grouped documents. An example of this is adding up the total number of movie tickets sold by using the $sum operator:

$group: { _id: "$movie", totalTickets: { $sum: "$tickets" } }

The "$movie" is the group key, and the totalTickets field is the result of the $sum operator.

In the following code, we assign our collection name to a variable for convenience. First, we declare some variables to hold the database connection and 
the collection we'll use:

const client = new MongoClient(uri)
const dbname = "bank";
const collection_name = "accounts";
const accountsCollection = client.db(dbname).collection(collection_name);
Next, we build an aggregation pipeline that uses $match and $group and that will find accounts with a balance of less than $1,000. Then we group the 
results by the account_type, and calculate the total_balance and avg_balance for each type.

const pipeline = [
  // Stage 1: match the accounts with a balance less than $1,000
  { $match: { balance: { $lt: 1000 } } },
  // Stage 2: Calculate average balance and total balance
  {
    $group: {
      _id: "$account_type",
      total_balance: { $sum: "$balance" },
      avg_balance: { $avg: "$balance" },
    },
  },
]
To run an aggregation pipeline, we append the aggregate method to the collection. The aggregate method takes an array of stages as an argument, which is
 stored in a variable. The aggregate method returns a cursor that we can iterate over to get the results.

const main = async () => {
  try {
    await client.connect()
    console.log(`Connected to the database üåç. \nFull connection string: ${safeURI}`)
    let result = await accountsCollection.aggregate(pipeline)
    for await (const doc of result) {
      console.log(doc)
    }
  } catch (err) {
    console.error(`Error connecting to the database: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Using MongoDB Aggregation Stages with Node.js: $sort and $project
Review the following code, which demonstrates how to build the $sort and $project stages of an aggregation pipeline in MongoDB with Node.js.

$sort
Aggregation is a powerful tool that gives us the ability to compute and transform our data. In this lesson, we focused on the $sort and $project stages.

The $sort stage takes all the input documents and sorts them in a specific order. The documents can be sorted in numerical, alphabetical, ascending, or 
descending order.

The $sort stage accepts a sort key that specifies the field to sort on. The sort key can be 1 for ascending order or -1 for descending order. For example:

{ $sort: { balance: 1 } } sorts the documents in ascending order by the balance field.

{ $sort: { balance: -1 } } sorts the documents in descending order by the balance field.

$project
The $project stage takes all the input documents and passes along only a subset of the fields in those documents by specifying the fields to include or 
exclude.

For example, if we want our resulting documents to include only the account_id, we write { $project: { _id: 0, account_id: 1 } }. The _id field is excluded
 by setting it to 0, and the account_id field is included by setting it to 1.

The $project stage can also create new computed fields based on data from the original documents. An example of this is creating a projected field that 
contains someone's full name, where only the first and last names are stored in the original document.

In the following example, we build an aggregation pipeline that uses $match, $sort, and $project, and that will find checking accounts with a balance of 
greater than or equal to $1,500. Then, we sort the results by the balance in descending order and return only the account_id, account_type, balance, and 
a new computed field named gbp_balance, which stands for Great British Pounds (GBP) balance.

const pipeline = [
  // Stage 1: $match - filter the documents (checking, balance >= 1500)
  { $match: { account_type: "checking", balance: { $gte: 1500 } } },

  // Stage 2: $sort - sorts the documents in descending order (balance)
  { $sort: { balance: -1 } },

  // Stage 3: $project - project only the requested fields and one computed field (account_type, account_id, balance, gbp_balance)
  {
    $project: {
      _id: 0,
      account_id: 1,
      account_type: 1,
      balance: 1,
      // GBP stands for Great British Pound
      gbp_balance: { $divide: ["$balance", 1.3] },
    },
  },
]
To run an aggregation pipeline, we append the aggregate method to the collection. The aggregate method takes an array of stages as an argument, which is 
stored here as a variable. The aggregate method returns a cursor that we can iterate over to get the results.

const main = async () => {
  try {
    await client.connect()
    console.log(`Connected to the database üåç\n ${uri}`)
    let accounts = client.db("bank").collection("accounts")
    let result = await accounts.aggregate(pipeline)
    for await (const doc of result) {
      console.log(doc)
    }
  } catch (err) {
    console.error(`Error connecting to the database: ${err}`)
  } finally {
    await client.close()
  }
}

main()

Creating a Single Field Index
Review the code below, which demonstrates how to create a single field index in a collection.


Create a Single Field Index
Use createIndex() to create a new index in a collection. Within the parentheses of createIndex(), include an object that contains the field and sort order.

db.customers.createIndex({
  birthdate: 1
})

Create a Unique Single Field Index
Add {unique:true} as a second, optional, parameter in createIndex() to force uniqueness in the index field values. Once the unique index is created, any 
inserts or updates including duplicated values in the collection for the index field/s will fail.

db.customers.createIndex({
  email: 1
},
{
  unique:true
})
MongoDB only creates the unique index if there is no duplication in the field values for the index field/s.


View the Indexes used in a Collection
Use getIndexes() to see all the indexes created in a collection.

db.customers.getIndexes()

Check if an index is being used on a query
Use explain() in a collection when running a query to see the Execution plan. This plan provides the details of the execution stages (IXSCAN , COLLSCAN, 
FETCH, SORT, etc.).

The IXSCAN stage indicates the query is using an index and what index is being selected.
The COLLSCAN stage indicates a collection scan is perform, not using any indexes.
The FETCH stage indicates documents are being read from the collection.
The SORT stage indicates documents are being sorted in memory.
db.customers.explain().find({
  birthdate: {
    $gt:ISODate("1995-08-01")
    }
  })
db.customers.explain().find({
  birthdate: {
    $gt:ISODate("1995-08-01")
    }
  }).sort({
    email:1
    })

Understanding Multikey Indexes
Review the code below, which demonstrates how multikey indexes work. If a single field or compound index includes an array field, then the index is a multikey index.


Create a Single field Multikey Index
Use createIndex() to create a new index in a collection. Include an object as parameter that contains the array field and sort order. In this example accounts is an array field.

db.customers.createIndex({
  accounts: 1
})

View the Indexes used in a Collection
Use getIndexes() to see all the indexes created in a collection.

db.customers.getIndexes()

Check if an index is being used on a query
Use explain() in a collection when running a query to see the Execution plan. This plan provides the details of the execution stages (IXSCAN , COLLSCAN, FETCH, SORT, etc.).

The IXSCAN stage indicates the query is using an index and what index is being selected.
The COLLSCAN stage indicates a collection scan is perform, not using any indexes.
The FETCH stage indicates documents are being read from the collection.
The SORT stage indicates documents are being sorted in memory.
db.customers.explain().find({
  accounts: 627788
  })
  
Working with Compound Indexes
Review the code below, which demonstrates how to create a compound index in a collection.


Create a Compound Index
Use createIndex() to create a new index in a collection. Within the parentheses of createIndex(), include an object that contains two or more fields and their sort order.

db.customers.createIndex({
  active:1, 
  birthdate:-1,
  name:1
})

Order of Fields in a Compound Index
The order of the fields matters when creating the index and the sort order. It is recommended to list the fields in the following order: Equality, Sort, and Range.

Equality: field/s that matches on a single field value in a query
Sort: field/s that orders the results by in a query
Range: field/s that the query filter in a range of valid values
The following query includes an equality match on the active field, a sort on birthday (descending) and name (ascending), and a range query on birthday too.

db.customers.find({
  birthdate: {
    $gte:ISODate("1977-01-01")
    },
    active:true
    }).sort({
      birthdate:-1, 
      name:1
      })
Here's an example of an efficient index for this query:

db.customers.createIndex({
  active:1, 
  birthdate:-1,
  name:1
})

View the Indexes used in a Collection
Use getIndexes() to see all the indexes created in a collection.

db.customers.getIndexes()

Check if an index is being used on a query
Use explain() in a collection when running a query to see the Execution plan. This plan provides the details of the execution stages (IXSCAN , COLLSCAN, FETCH, SORT, etc.). Some of these are:

The IXSCAN stage indicates the query is using an index and what index is being selected.
The COLLSCAN stage indicates a collection scan is perform, not using any indexes.
The FETCH stage indicates documents are being read from the collection.
The SORT stage indicates documents are being sorted in memory.
db.customers.explain().find({
  birthdate: {
    $gte:ISODate("1977-01-01")
    },
  active:true
  }).sort({
    birthdate:-1,
    name:1
    })

Cover a query by the Index
An Index covers a query when MongoDB does not need to fetch the data from memory since all the required data is already returned by the index.

In most cases, we can use projections to return only the required fields and cover the query. Make sure those fields in the projection are in the index.

By adding the projection {name:1,birthdate:1,_id:0} in the previous query, we can limit the returned fields to only name and birthdate. These fields are part of the index and when we run the explain() command, the execution plan shows only two stages:

IXSCAN - Index scan using the compound index
PROJECTION_COVERED - All the information needed is returned by the index, no need to fetch from memory
db.customers.explain().find({
  birthdate: {
    $gte:ISODate("1977-01-01")
    },
  active:true
  },
  {name:1,
    birthdate:1, 
    _id:0
  }).sort({
    birthdate:-1,
    name:1
    })
	
Deleting an Index
Review the code below, which demonstrates how to delete indexes in a collection.


View the Indexes used in a Collection
Use getIndexes() to see all the indexes created in a collection. There is always a default index in every collection on _id field. This index is used by MongoDB internally and cannot be deleted.

db.customers.getIndexes()

Delete an Index
Use dropIndex() to delete an existing index from a collection. Within the parentheses of dropIndex(), include an object representing the index key or provide the index name as a string.

Delete index by name:

db.customers.dropIndex(
  'active_1_birthdate_-1_name_1'
)
Delete index by key:

db.customers.dropIndex({
  active:1,
  birthdate:-1, 
  name:1
})

Delete Indexes
Use dropIndexes() to delete all the indexes from a collection, with the exception of the default index on _id.

db.customers.dropIndexes()
The dropIndexes() command also can accept an array of index names as a parameter to delete a specific list of indexes.

db.collection.dropIndexes([
  'index1name', 'index2name', 'index3name'
  ])