5432 Is used to connect to PostgreSQL database services.
3306/3307 are used in connections to the MySQL database.
587 Used for SMTP connections (Simple Mail Transfer Protocol, the protocol for sending and receiving emails).
80 Is the default HTTP connection port used by browsers.

Respostas Informativas (100 – 199)
Respostas bem-sucedidas (200 – 299)
Mensagens de redirecionamento (300 – 399)
Respostas de erro do cliente (400 – 499)
Respostas de erro do servidor (500 – 599)
201= que é o código de status HTTP para registro criado.

O content-type tem duas partes: tipo e subtipo. Por exemplo:

Um servidor pode devolver uma imagem no formato png. O content-type da resposta viria como image/png;
Se fosse um jpg, o content-type seria image/jpg;
E se fosse um arquivo html? text/html;
E um json? text/json.

201= que é o código de status HTTP para registro criado.

Async-> Essa palavra pode ser usada ao criar uma função convencional. Quando adicionamos esse identificador
na criação desta função, nós definimos que ela será uma função assíncrona, e o melhor, retornará uma promessa!
Quando usarmos a expressão return estaremos, na realidade, resolvendo uma promessa.

Await-> Essa palavra será usada com o objetivo de esperar a resolução de uma função assíncrona.
Se houver uma série de funções assíncronas, a expressão await definirá que o código só terá sequência quando a função anterior for resolvida.

Adicionando a rota de busca: routes.get("/livros/busca", LivroController.listarLivrosPorEditora);
http://localhost:3000/livros/busca?editora=Classicos
http://localhost:3000/livros/busca?editora=Classicos&titulo=O Hobbit
No arquivo Livro.js:
Ao invés do autorSchema, adicionamos a propriedade autor tendo como valor um ID do tipo ObjectId do MongoDB, fazendo referência à coleção autores.

const livroSchema = new mongoose.Schema({
 id: { type: mongoose.Schema.Types.ObjectId },
 titulo: { type: String, required: true },
 editora: { type: String },
 preco: { type: Number },
 paginas: { type: Number },
 autor: {type: mongoose.Schema.Types.ObjectId, ref: 'autores', required: true},
}, { versionKey: false });

No arquivo livroController.js:
Quando usamos references o autor não faz mais parte do objeto livro. Assim, cada livro deve ser “populado” com as referências do autor.

Os métodos livro.find({}).populate("autor").exec(); vão utilizar o ID informado no campo autor do livro para buscar a referência desse ID e “popular”
 a propriedade.

 static async listarLivros (req, res) {
   try {
     const listaLivros = await livro.find({}).populate("autor").exec();
     res.status(200).json(listaLivros);
   } catch (erro) {
     res.status(500).json({ message: `${erro.message} - falha na requisição` });
   }
 };

Já o método de cadastrar livro fica como estava anteriormente, pois agora o schema Livro apenas recebeu a propriedade autor com o tipo de dado ID.

 static async cadastrarLivro (req, res) {
   try {
     const novoLivro = await livro.create(req.body);
     res.status(201).json({ message: "criado com sucesso", livro: novoLivro });
   } catch (erro) {
     res.status(500).json({ message: `${erro.message} - falha ao cadastrar livro` });
   }
 }